from collections import deque
import numpy as np
from pathlib import Path

def xma_valid(validation_set, xma_value):
    validation_intersection = validation_set.intersection(set([xma_value - x for x in validation_set]))
    return validation_intersection and not (len(validation_intersection)==1 and xma_value/2 in validation_intersection)

def xma_validator(file,history_length):
    xma_history=deque([], maxlen=history_length)
    validation_set = set()
    with open(file) as fii:
        for line in fii:
            xma_value = int(line)
            # if we haven't filled with the preamble, put it into the dequeu container and validation set
            if len(xma_history) != history_length:
                xma_history.append(xma_value)
                validation_set.add(xma_value)

            # if the pre-amble is already filled, check if the xma_value can be made by the sum of two values
            # in the set. If not, yield the value
            # then remove the earliest value from the set and add the current xma value
            # print(xma_value)
            # print(validation_set)
            # print(xma_valid())
            else:
                if not xma_valid(validation_set, xma_value):
                    yield xma_value
                
                # now append this current input to the input set
                validation_set.discard(xma_history.popleft()) # remove the furthest out sample
                xma_history.append(xma_value)
                validation_set.add(xma_value)


def part1_solution(input_file, history):
    """
    runs the XMA generator to yield the first int that can't be generated by the sum of the previous
    N values
    """
    xma_generator = xma_validator(input_file,history)
    return next(xma_generator)

def part2_solution(input_file, search_key):
    """
    load the entire input file into memory
    split into subsets where any number>=search key is the split factor
    for each subset do a convolution of varying lengths, after each convolution check if the search key is in the result
    if the search key was found, calculate the max+min of the range that generated the search key & return
    """

    with open(input_file) as fii:
        input_array = np.array([int(line) for line in fii])
    # make an array of split indices, which is where the input is greater than the search key
    split_indices = np.arange(input_array.shape[0])[input_array>=search_key]

    # make the sublist and iterate over it
    for head, tail in zip(np.insert(split_indices+1,0,0),np.insert(split_indices,split_indices.shape[0],input_array.shape[0])):
        sub_array = input_array[head:tail]
        # print(f"{head}\t{tail}")
        # only bother searching if the subarray is greater than 2
        if sub_array.shape[0]>=2: 
            for convolution_length in range(2,len(sub_array)):
                sum_set = np.convolve(sub_array,np.ones(convolution_length),mode='valid')
                search_in_sums = np.where(sum_set==search_key)[0]
                # if the search was not empty
                if search_in_sums.shape[0]>0:
                    # pick apart the sub-array to get the range that sums to the search key
                    chunk_start = search_in_sums[0]
                    chunk_end = search_in_sums[0] + convolution_length
                    # print(f"chunk: {chunk_start},{chunk_end}:{convolution_length}")
                    chunk = sub_array[chunk_start:chunk_end]
                    # print(chunk)
                    return(np.min(chunk)+np.max(chunk)) 
        

if __name__ == '__main__':
    input_file = Path(__file__).resolve().parents[2] / "inputs" / "day9.txt"
    
    part1_answer = part1_solution(input_file, 25)
    print(f"Part 1 Solution: {part1_answer}")
    
    part2_answer = part2_solution(input_file, part1_answer)
    print(f"Part 2 Solution: {part2_answer}")